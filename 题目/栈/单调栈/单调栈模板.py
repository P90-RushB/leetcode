# 讲解单调栈问题非常好的：还是labuladong：
# https://github.com/labuladong/fucking-algorithm/blob/master/数据结构系列/单调栈.md
# 以上文中所描述的排队看身高的问题，来写单调栈的模板。
# 排队看身高的问题：给一个数组，每个数表示一个人的身高。返回一个相同长度的数组，每个位置表示
# 当前这个人网友看，第一个比自己高的人的身高,右边没有比自己高的就返回-1

# 单调栈方法，每个元素最多压栈出栈一次，所以时间复杂度O（n）

# 单调栈模板。
# 示例任务： 对nums中的每个数，得到第一个比该数大的后面的数，返回列表
def myd_dandiao(nums):
    # 单调栈：s
    s = []

    # 结果列表： res
    n = len(nums)
    res = [0] * n

    # 倒着遍历
    for i in range(n-1, -1, -1):
        # 想想一排人往右看，看的时候低的都剔除，直到第一个比本人高的。
        # 想象这样的场面：一排人从左往右，最右边有一个左边开口的栈。
        # 每次，最右边的人往栈里怼，压到栈最里面（右边）
        # 这个while就是在判断，当当前栈不空，并且剩下的一排人最右边
        # 要大于栈顶，说明栈顶那个比一排最右边的矮，就把栈顶那个扔出去。
        while s and s[-1] <=nums[i]:
            s.pop()

        # 如果栈不空，说明当前栈顶的人比当前i要高，因此把它作为结果（最近的更大值）
        # 否则，-1.，说明没有比i高的。

        res[i] = s[-1] if s else -1
        # 把i压栈，继续循环。dd
        s.append(nums[i])
    return res

s = myd_dandiao([2,1,2,4,3])
print(s)

