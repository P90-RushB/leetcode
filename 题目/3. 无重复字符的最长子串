//用的哈希表，时间复杂度On  
//求解的思路是：
我们先不考虑代码怎么实现，如果给一个例子中的例子"abcabcbb"，让你手动找无重复字符的子串，该怎么找。博主会一个字符一个字符的遍历，比如a，b，c，
然后又出现了一个a，那么此时就应该去掉第一次出现的a，然后继续往后，又出现了一个b，则应该去掉一次出现的b，以此类推，最终发现最长的长度为3。所以说，
我们需要记录之前出现过的字符，记录的方式有很多，最常见的是统计字符出现的个数，但是这道题字符出现的位置很重要，所以我们可以使用HashMap来建立字符
和其出现位置之间的映射。进一步考虑，由于字符会重复出现，到底是保存所有出现的位置呢，还是只记录一个位置？我们之前手动推导的方法实际上是维护了一个
滑动窗口，窗口内的都是没有重复的字符，我们需要尽可能的扩大窗口的大小。由于窗口在不停向右滑动，所以我们只关心每个字符最后出现的位置，并建立映射。
窗口的右边界就是当前遍历到的字符的位置，为了求出窗口的大小，我们需要一个变量left来指向滑动窗口的左边界，这样，如果当前遍历到的字符从未出现过，那
么直接扩大右边界，如果之前出现过，那么就分两种情况，在或不在滑动窗口内，如果不在滑动窗口内，那么就没事，当前字符可以加进来，如果在的话，就需要先
在滑动窗口内去掉这个已经出现过的字符了，去掉的方法并不需要将左边界left一位一位向右遍历查找，由于我们的Ha
shMap已经保存了该重复字符最后出现的位置，所以直接移动left指针就可以了。我们维护一个结果res，每次用出现过的窗口大小来更新结果res，就可以得到最终结果啦。
public class Solution {
    public int LengthOfLongestSubstring(string s) {
    //result保存最长子串的长度， start标志目前遍历的字串的开始位置
    int result=0,start=0;
    //建立一个哈希表，key为字符，value为字符所在的索引位置
        var hashtable=new Dictionary<char,int>();
        //遍历字符
        for(var i=0;i<s.Length;i++)
        {
        //current为当前字符
            var current=s[i];
            //若哈希表中已经包含此字符并且包含的此字符的索引大于start，也就是大于目前子串的开始位置（说明该字符已经在目前的子串中）
            if(hashtable.ContainsKey(current)&&hashtable[current]>=start)
            {
            //则目前的子串需要变，字串的开始位置为目前current字符索引位置的下一位
                start=hashtable[current]+1;
            }
            //更新current这个字符在哈希表中的value（索引位）
            hashtable[current]=i;
            //最长子串判断是否需要更新
            result=Math.Max(result,i-start+1);
        }
        return result;
    }
}
