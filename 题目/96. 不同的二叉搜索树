//给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？
//思路：题目说明二叉树的节点是从1到n，所以我们能确定如果根为k，则根左边的数是1到k-1，根右边的数是k+1到n。
//另外，对于一个根，唯一二叉树的数量是其左子树的数量乘以右子树的数量
//并且，左右子树的形态数量是跟具体的数无关的，只跟这个树里有多少节点有关。而根可以选择从1到n的任意的数，唯一二叉树的总数，就是根为1到n的树相加。
//所以该问题化简为以k为根，其唯一左子树和右子树各有多少，这就是个动态规划的问题了。我们建立一个数组dp[i]，代表节点数为i的唯一子树有多少个。
public class Solution {
    public int NumTrees(int n) {
      if(n<=0)
          return 0;
        int[] res=new int[n+1];
        res[0]=1;
        res[1]=1;
        for(int i=2;i<=n;i++)//i为节点的数量，因为求的是节点数为n的唯一二叉树数目，需要用到小于n个节点的唯一二叉树的数量。
        {
            for(int j=0;j<i;j++)//当节点数为i，左子树的节点数量为j时
            {
                res[i]+=res[j]*res[i-j-1];//左子树节点数为j，则右子树节点数量为i-j-1.利用性质唯一二叉树数量为左子树数量乘以右数量。
            }
        }
        return res[n];
    }
}
