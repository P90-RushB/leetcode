这道题需要两个字典，为什么呢？： 
例如 s ="aa" ,t = "bc" ，那么遍历第一个字典的时候 会得到 map<'a' , 'b'>，第二个'a'的时候找到应该把'a'对应成'b'，但是给的是c所以能发现错了。
但是如果不用第二个字典，把两个字符串交换一下就错了，即s = "bc" ,t = "aa"， 第一个得到map<'b','a'>，第二个得到map<'c'，'a'>，返回true。
于是，不能只满足单向对应关系，要双向对应关系都满足才可以。

这题可以用256数组来代替字典，我还是用字典吧。

c#:
public class Solution {
    public bool IsIsomorphic(string s, string t) {
       if(s.Length!=t.Length)
           return false;
        var sHash=new Dictionary<char,char>();
        for(int i=0;i<s.Length;i++)
        {
            if(sHash.ContainsKey(s[i]))
            {
                if(sHash[s[i]]!=t[i])
                    return false;
            }
            else 
            {
             sHash.Add(s[i],t[i]);    
            }
        }
        
        var sHash2=new Dictionary<char,char>();
        for(int i=0;i<s.Length;i++)
        {
            if(sHash2.ContainsKey(t[i]))
            {
                if(sHash2[t[i]]!=s[i])
                    return false;
            }
            else
            {
                sHash2.Add(t[i],s[i]);
            }
        }
        return true;
        
    }
}

python :
class Solution:
    def isIsomorphic(self, s, t):
        """
        :type s: str
        :type t: str
        :rtype: bool
        """
        if(len(s)!=len(t)):
            return Fales
        else:
            mapping={}
            for i in range(len(s)):
                if s[i] in mapping:
                    if(mapping[s[i]]!=t[i]):
                        return False
                else:
                    mapping[s[i]]=t[i]
            mapping1={}
            for i in range(len(t)):
                if t[i] in mapping1:
                    if(mapping1[t[i]]!=s[i]):
                        return False
                else:
                    mapping1[t[i]]=s[i]
            return True
